<!--https://github.com/JarenChow/Janvas Created by JarenChow in 2020-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AboutAntVPerformanceTest</title>
  <style type="text/css">
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

<canvas style="width: 928px;height: 530px;"></canvas>

<script src="../dist/janvas.min.js"></script>
<script>
  var antV = function (canvas) {
    var width = canvas.offsetWidth, height = canvas.offsetHeight,
      ctx = canvas.getContext("2d", {alpha: true, desynchronized: false}),
      stg = new Setting(ctx);

    // 简单写一下：面向对象复用原型，节省内存
    function Node(id, x, y, label) {
      this._defaultRadius = 1;
      this._show = true;
      this._highlight = false;
      this.arc = new FixedArc(ctx, 0, 0, this._defaultRadius);
      this.arc.getStyle().setFillStyle("#C6E5FF").setStrokeStyle("#5B8FF9").setLineWidth(0.3);
      this.mat = this.arc.mat.setOffset(x, y);
      this.text = new Text(ctx, x + this._defaultRadius + 1, y, label || id, x + this._defaultRadius + 1, y);
      this.text.getStyle().setFont("1.5px sans-serif").setTextAlign("left").setTextBaseline("middle");
    }

    Node.prototype = {
      setXY: function (x, y) {
        this.mat.setOffset(x, y);
        this.text.sx = this.text.cx = x + (this._defaultRadius + 1) * scale;
        this.text.sy = this.text.cy = y;
      },
      inScreen: function () {
        var x = this.mat.getOffsetX(), y = this.mat.getOffsetY();
        return x > 0 && x < width && y > 0 && y < height;
      },
      draw: function () {
        if (this.inScreen()) this.arc.fillStroke();
        // if (show) text.fill();
      },
      getX: function () {
        return this.mat.getOffsetX();
      },
      getY: function () {
        return this.mat.getOffsetY();
      },
      mark: function () {
        this.lastX = this.mat.getOffsetX();
        this.lastY = this.mat.getOffsetY();
      },
      drag: function (moveX, moveY) {
        this.setXY(this.lastX + moveX, this.lastY + moveY, 1);
      },
      wheel: function (x, y, scaling, scale) {
        this.setXY(x + (this.mat.getOffsetX() - x) * scaling, y + (this.mat.getOffsetY() - y) * scaling, scale);
        this.mat.setScale(scale, scale);
        this.text.getMatrix().setScale(scale, scale);
      },
      hide: function () {
        this._show = false;
      },
      show: function () {
        this._show = true;
      },
      isPointInPath: function (x, y) {
        if (!this.inScreen()) return false;
        return this.arc.isPointInPath(x, y);
      },
      highlight: function (flag) {
        if (flag) {
          this.arc.getStyle().setFillStyle("#FF0000").setStrokeStyle("#000000").setLineWidth(1);
          this._highlight = true;
        } else {
          this.arc.getStyle().setFillStyle("#C6E5FF").setStrokeStyle("#5B8FF9").setLineWidth(0.3);
          this._highlight = false;
        }
      },
      isHighlight: function () {
        return this._highlight;
      },
      getLabel: function () {
        return this.text.getText();
      }
    };

    // 以闭包的方式由工厂函数创建对象
    var factory = {
      nodesMap: new Map(),
      // 使用闭包方式，创建节点对象，由 Arc 和 Text 组成（大数据量时 Text 不绘制）
      createNode: function (id, x, y, label) {
        var defaultRadius = 1;
        var arc = new FixedArc(ctx, 0, 0, defaultRadius);
        arc.getStyle().setFillStyle("#C6E5FF").setStrokeStyle("#5B8FF9").setLineWidth(0.3);
        var mat = arc.getMatrix();
        mat.setOffset(x, y);
        var text = new Text(ctx, x + defaultRadius + 1, y, label || id, x + defaultRadius + 1, y);
        text.getStyle().setFont("1.5px sans-serif").setTextAlign("left").setTextBaseline("middle");

        function setXY(x, y) {
          mat.setOffset(x, y);
          text.sx = text.cx = x + (defaultRadius + 1) * scale;
          text.sy = text.cy = y;
        }

        function inScreen() {
          var x = mat.getOffsetX(), y = mat.getOffsetY();
          return x > 0 && x < width && y > 0 && y < height;
        }

        var show = true;
        var highlight = false;

        var node = {
          draw: function () {
            if (inScreen()) arc.fillStroke();
            // if (show) text.fill();
          },
          getX: function () {
            return mat.getOffsetX();
          },
          getY: function () {
            return mat.getOffsetY();
          },
          mark: function () {
            this.lastX = mat.getOffsetX();
            this.lastY = mat.getOffsetY();
          },
          drag: function (moveX, moveY) {
            setXY(this.lastX + moveX, this.lastY + moveY, 1);
          },
          wheel: function (x, y, scaling, scale) {
            setXY(x + (mat.getOffsetX() - x) * scaling, y + (mat.getOffsetY() - y) * scaling, scale);
            mat.setScale(scale, scale);
            text.getMatrix().setScale(scale, scale);
          },
          hide: function () {
            show = false;
          },
          show: function () {
            show = true;
          },
          isPointInPath: function (x, y) {
            if (!inScreen()) return false;
            return arc.isPointInPath(x, y);
          },
          highlight: function (flag) {
            if (flag) {
              arc.getStyle().setFillStyle("#FF0000").setStrokeStyle("#000000").setLineWidth(1);
              highlight = true;
            } else {
              arc.getStyle().setFillStyle("#C6E5FF").setStrokeStyle("#5B8FF9").setLineWidth(0.3);
              highlight = false;
            }
          },
          isHighlight: function () {
            return highlight;
          },
          getLabel: function () {
            return text.getText();
          }
        };
        this.nodesMap.set(id, node);
        return node;
      },
      // 使用面向对象的方式创建节点对象
      newNode: function (id, x, y, label) {
        var node = new Node(id, x, y, label);
        this.nodesMap.set(id, node);
        return node;
      },
      // 使用必包方式，创建连线对象，仅由 Line 组成
      createEdge: function (source, target) {
        var sourceNode = this.nodesMap.get(source), targetNode = this.nodesMap.get(target);
        if (sourceNode === void (0) || targetNode === void (0)) return;
        var line = new Line(ctx, sourceNode.getX(), sourceNode.getY(), targetNode.getX(), targetNode.getY());
        line.getStyle().setStrokeStyle("#333333").setLineWidth(0.1);

        var show = true;

        return {
          draw: function () {
            if (show) line.stroke();
          },
          refresh: function () {
            line.initXY(sourceNode.getX(), sourceNode.getY())
              .setEndX(targetNode.getX()).setEndY(targetNode.getY());
          },
          lineWidth: function (scale) {
            line.getStyle().setLineWidth(scale / 10);
          },
          hide: function () {
            show = false;
          },
          show: function () {
            show = true;
          }
        }
      },
      // 创建提示框对象
      createHint: function () {
        var roundRect = new RoundRect(ctx, 0, 0, 0, 0);
        roundRect.getStyle().setFillStyle("white").setStrokeStyle("white");
        var text = new Text(ctx, 0, 0, "");
        text.getStyle().setFont("12px sans-serif").setTextAlign("left").setTextBaseline("bottom");

        var shadow = new ShadowStyle().setShadowBlur(20).setShadowColor("grey");

        var show = false;

        var of = 3, pdl = 5, pdt = 3; // offset, paddingLeft, paddingTop

        return {
          draw: function () {
            if (show) {
              stg.setShadowStyles(shadow);
              roundRect.fill().stroke();
              stg.resetShadowStyles();
              text.fill();
            }
          },
          init: function (x, y, label) {
            x += of;
            y -= of;
            text.setText(label);
            var metrics = Utils.measureText(label, text.getStyle().getFont());
            text.initXY(x + pdl, y - pdt);
            roundRect.initXY(x, y).setWidth(metrics.width + pdl * 2).setHeight(-(metrics.height + pdt * 2)).setRadius();
          },
          hide: function () {
            show = false;
          },
          show: function () {
            show = true;
          }
        };
      }
    };

    // 需要绘制的节点对象列表
    var nodes = [];

    // 需要绘制的连线对象列表
    var edges = [];

    // 提示框
    var hint = factory.createHint();

    resize();

    function resize() {
      canvas.width = width = canvas.offsetWidth;
      canvas.height = height = canvas.offsetHeight;
      stg.initCurrentStyles();
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      edges.forEach(function (edge) {
        edge.draw();
      });
      nodes.forEach(function (node) {
        node.draw();
      });
      hint.draw();
    }

    var x, y, lastX, lastY, moveX, moveY;
    var current, mousein;

    function mousedown(ev) {
      lastX = x = ev.offsetX;
      lastY = y = ev.offsetY;
      nodes.forEach(function (node) {
        node.mark();
        node.hide();
      });
      if (current === void (0)) {
        edges.forEach(function (edge) {
          edge.hide();
        });
      }
      draw();
    }

    function mousemove(ev) {
      x = ev.offsetX;
      y = ev.offsetY;
      moveX = x - lastX;
      moveY = y - lastY;
      switch (ev.buttons) {
        case 0:
          mousein = true;
          nodes.forEach(function (node) {
            if (node.isPointInPath(x, y)) {
              current = node;
              mousein = false;
            }
          });
          nodes.forEach(function (node) {
            if (node.isHighlight()) {
              node.highlight(false);
            }
          });
          if (mousein) {
            current = void (0);
            hint.hide();
          } else {
            current.highlight(true);
            hint.show();
            hint.init(x, y, current.getLabel());
          }
          break;
        case 1:
          if (current) {
            current.drag(moveX, moveY);
          } else {
            nodes.forEach(function (node) {
              node.drag(moveX, moveY);
            });
          }
          edges.forEach(function (edge) {
            edge.refresh();
          });
          break;
      }
      draw();
    }

    function mouseup(ev) {
      x = ev.offsetX;
      y = ev.offsetY;
      nodes.forEach(function (node) {
        node.show();
      });
      edges.forEach(function (edge) {
        edge.show();
      });
      draw();
    }

    var scale = 1, lastScale, scaling;

    function wheel(ev) {
      x = ev.offsetX;
      y = ev.offsetY;
      lastScale = scale;
      scale += 0.5 * (ev.deltaY > 0 ? -1 : 1);
      scale = Math.min(Math.max(0.5, scale), 8);
      scaling = scale / lastScale;
      nodes.forEach(function (node) {
        node.wheel(x, y, scaling, scale);
        node.mark();
      });
      edges.forEach(function (edge) {
        edge.refresh();
        edge.lineWidth(scale);
      });
      lastX = x;
      lastY = y;
      draw();
    }

    canvas.addEventListener("mousedown", mousedown);
    canvas.addEventListener("mousemove", mousemove);
    canvas.addEventListener("mouseup", mouseup);
    canvas.addEventListener("mouseout", mouseup);
    canvas.addEventListener("wheel", wheel);
    addEventListener("resize", resize);

    return {
      data: function (data) {
        // 每次进来数据时进行重置与闭包清理
        scale = 1;
        nodes.forEach(function (node) {
          for (var key in node) node[key] = null;
          node = null;
        });
        edges.forEach(function (edge) {
          for (var key in edge) edge[key] = null;
          edge = null;
        });
        nodes.length = edges.length = 0;
        // 节点数据进来，使用工厂模式循环创建节点与连线对象
        data.nodes.forEach(function (node) {
          // nodes.push(factory.createNode(node.id, node.x, node.y, node.olabel));
          nodes.push(factory.newNode(node.id, node.x, node.y, node.olabel)); // 使用面向对象方式生成 Node，复用原型方法，节省内存
        });
        data.edges.forEach(function (edge) {
          edge = factory.createEdge(edge.source, edge.target);
          if (edge) edges.push(edge);
        });
        draw();
      }
    };
  };

  var antv = antV(document.querySelector("canvas"));

  // 原示例：https://g6.antv.vision/zh/examples/performance/perf#moreData
  fetch("https://gw.alipayobjects.com/os/bmw-prod/f1565312-d537-4231-adf5-81cb1cd3a0e8.json")
    .then(function (res) {
      return res.json();
    }).then(function (data) {
    antv.data(data);
  });
</script>

</body>
</html>
